/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package project;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.net.URL;
import java.util.Random;
import java.util.ResourceBundle;
import javax.swing.ImageIcon;
import javax.swing.Timer;

/**
 * H κλαση αυτη αναφερεται στο graphical user interface οσον αφορα το παιχνιδι
 * για 2 παικτες.
 *
 * @
 * @version 1.0
 *
 */
public class Gui2 extends javax.swing.JFrame {

    static final int NUMBER_OF_ROUNDS = 3;
    private Timer timer;
    private long time;
    private ResourceBundle bundle;
    private int rightAnswer;
    private String language;
    private String txt;
    private int flagForRound;
    private int numberOfPlayedQuestions;
    private Question q = new Question();
    private int numberOfRounds;
    private GamePlay gamePlay;
    private final int player1 = 1;
    private final int player2 = 2;
    private Player ster = new Player(0);
    private Player eleni = new Player(0);
    private boolean theFirstWhoAnswered = false;
    private int bet = 0;
    private int betTwo = 0;
    private int hasBothBet = 0;
    private ImageIcon icon;
    private ScoreWriter scoreWriter;
    private int counter1 = 0;
    private int counter2 = 0;
    private boolean firstRightAnswer = true;
    private boolean isInitialized = false;

    public Gui2() {
        numberOfRounds = 0;
        rightAnswer = -10;
        numberOfPlayedQuestions = 0;
        initComponents();
        disableBets();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        progress = new javax.swing.JLabel();
        image = new javax.swing.JLabel();
        play = new javax.swing.JButton();
        answers = new javax.swing.JPanel();
        answer1 = new javax.swing.JLabel();
        answer2 = new javax.swing.JLabel();
        answer3 = new javax.swing.JLabel();
        answer4 = new javax.swing.JLabel();
        category = new javax.swing.JLabel();
        betInfo = new javax.swing.JLabel();
        answer = new javax.swing.JLabel();
        clock = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        bet1 = new javax.swing.JRadioButton();
        bet3 = new javax.swing.JRadioButton();
        bet2 = new javax.swing.JRadioButton();
        bet4 = new javax.swing.JRadioButton();
        question = new javax.swing.JLabel();
        player1Info = new javax.swing.JLabel();
        player2Info = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        file = new javax.swing.JMenu();
        exit = new javax.swing.JMenuItem();
        Language = new javax.swing.JMenu();
        Greek = new javax.swing.JMenuItem();
        English = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        progress.setText("First choose a language, then play...");

        play.setText("PLAY");
        play.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                playActionPerformed(evt);
            }
        });
        play.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                playKeyPressed(evt);
            }
        });

        javax.swing.GroupLayout answersLayout = new javax.swing.GroupLayout(answers);
        answers.setLayout(answersLayout);
        answersLayout.setHorizontalGroup(
            answersLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(answersLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(answersLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(answer1, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(answersLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(answer3, javax.swing.GroupLayout.DEFAULT_SIZE, 223, Short.MAX_VALUE)
                        .addComponent(answer4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(answer2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addGap(0, 20, Short.MAX_VALUE))
        );
        answersLayout.setVerticalGroup(
            answersLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(answersLayout.createSequentialGroup()
                .addComponent(answer1, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(answer2, javax.swing.GroupLayout.PREFERRED_SIZE, 19, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(answer3, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(answer4, javax.swing.GroupLayout.DEFAULT_SIZE, 16, Short.MAX_VALUE)
                .addContainerGap())
        );

        answer.setPreferredSize(new java.awt.Dimension(10, 10));

        clock.setForeground(new java.awt.Color(255, 0, 0));

        bet1.setText("jRadioButton1");
        bet1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bet1ActionPerformed(evt);
            }
        });
        bet1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                bet1KeyPressed(evt);
            }
        });

        bet3.setText("jRadioButton3");
        bet3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bet3ActionPerformed(evt);
            }
        });
        bet3.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                bet3KeyPressed(evt);
            }
        });

        bet2.setText("jRadioButton2");
        bet2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bet2ActionPerformed(evt);
            }
        });
        bet2.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                bet2KeyPressed(evt);
            }
        });

        bet4.setText("jRadioButton4");
        bet4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bet4ActionPerformed(evt);
            }
        });
        bet4.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                bet4KeyPressed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(bet1, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(bet2, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(11, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(bet3, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(12, 12, 12)
                        .addComponent(bet4, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bet1, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(bet2))
                .addGap(5, 5, 5)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bet3, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(bet4))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        file.setText("File");

        exit.setText("Exit");
        exit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitActionPerformed(evt);
            }
        });
        file.add(exit);

        jMenuBar1.add(file);

        Language.setText("Language");

        Greek.setText("Ελληνικά");
        Greek.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GreekActionPerformed(evt);
            }
        });
        Language.add(Greek);

        English.setText("English");
        English.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EnglishActionPerformed(evt);
            }
        });
        Language.add(English);

        jMenuBar1.add(Language);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(category, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(progress, javax.swing.GroupLayout.PREFERRED_SIZE, 632, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(300, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(17, 17, 17)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(answer, javax.swing.GroupLayout.PREFERRED_SIZE, 333, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(answers, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(89, 89, 89))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(9, 9, 9)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(question, javax.swing.GroupLayout.PREFERRED_SIZE, 418, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(betInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 238, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(12, 12, 12)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(play)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(147, 147, 147)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addGap(27, 27, 27)
                                                .addComponent(image, javax.swing.GroupLayout.PREFERRED_SIZE, 174, javax.swing.GroupLayout.PREFERRED_SIZE))
                                            .addComponent(clock, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                .addContainerGap())
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(player2Info, javax.swing.GroupLayout.PREFERRED_SIZE, 217, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(player1Info, javax.swing.GroupLayout.PREFERRED_SIZE, 217, javax.swing.GroupLayout.PREFERRED_SIZE)))))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(22, 22, 22)
                        .addComponent(play))
                    .addComponent(progress, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(category, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(15, 15, 15)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(91, 91, 91)
                        .addComponent(clock, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(betInfo, javax.swing.GroupLayout.PREFERRED_SIZE, 52, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(105, 105, 105)
                        .addComponent(question, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(19, 19, 19)
                        .addComponent(answers, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(26, 26, 26)
                        .addComponent(answer, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(46, 46, 46)
                        .addComponent(player1Info, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(player2Info, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(109, 109, 109)
                        .addComponent(image, javax.swing.GroupLayout.PREFERRED_SIZE, 146, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        category.getAccessibleContext().setAccessibleName("category");
        betInfo.getAccessibleContext().setAccessibleName("bet");

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Πατωντας exit ο χρηστης κλεινει το παραθυρο και τερματιζει η εφαρμογη
     * καλωντας την dispose().
     *
     * @param evt το γεγονος ActionEvent
     */
    private void exitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitActionPerformed
        dispose();
    }//GEN-LAST:event_exitActionPerformed

    /**
     * Αν το isInitialized ειναι false σημαινει οτι δεν επελεξε πρωτα γλωσσα
     * ωστε να φορτωθουν τα δεδομενα και ετσι του βγαζει μηνυμα λαθους ωστε να
     * διαλεξει γλωσσα πρωτα και μετα να πατησει το κουμπι.
     *
     * Οταν πατησει το κουμπι του Play ,τοτε διαλεγεται ενας τυχαιος αριθμος απο
     * 0-4 με την βοηθεια της συναρτησης getRandom που αντιστοιχει στον εκαστοτε
     * γυρο. Δημιουργειται ενα αντικειμενο της κλασης GamePlay στο οποιο περναμε
     * ως παραμετρους τα txt και language που ειχαν αρχικοποιηθει νωριτερα, στο
     * πεδιο bundle του Gui2 παιρνω το ιδιο bundle με αυτο της κλασης παιχνιδιου
     * που φτιαχτηκε ωστε τα μηνυματα να βγαινουν στην ιδια γλωσσα και
     * "τραβιεται" μια ερωτηση απο τον συγκεκριμενο γυρο μεσω του αντικειμενου
     * gamePlay και της μεθοδου getAQuestionFromARound βαση αυτου του τυχαιου
     * αριθμου .Μετα καλειται η playGame για τον παραπανω αριθμο-γυρο (αναλυεται
     * παρακατω).
     *
     * @param evt το γεγονος ActionEvent
     */
    private void playActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_playActionPerformed
        if (isInitialized == false) {
            question.setText(" CHOOCE LANGUAGE AND THEN PLAY !!  ");
        } else {
            flagForRound = getRandom();
            try {
                gamePlay = new GamePlay(txt, language);
                bundle = gamePlay.getBundle();
                q = gamePlay.getAQuestionFromARound(flagForRound);
                playGame(flagForRound);
            } catch (IOException ex) {
            }
        }
    }//GEN-LAST:event_playActionPerformed

    /**
     * KeyPressed στην φορμα λογω focus
     *
     * @param evt
     */
    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        keyPressed(evt);

    }//GEN-LAST:event_formKeyPressed

    //PEIRAMATIKA ARKEI NA BALW SE 1 MEXRI STIGMHS(EVALA STIN PROKEIMENH STO PLAY), BOREI ARGOTERA NA XREIASTEI NA
    //BALW KAI SE ALLA
    /**
     * KeyPressed στην φορμα λογω focus
     *
     * @param evt
     */
    private void playKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_playKeyPressed
        keyPressed(evt);
    }//GEN-LAST:event_playKeyPressed

    /**
     * Υλοποιηση της keyPressed κανοντας setFocusable(true) ωστε να μην χανεται
     * ο ελεγχος του προγραμματος οταν ο χρηστης πατησει κουμπι για
     * απαντηση.Επισης καλειται η foo2(αναλυεται παρακατω).
     *
     * @param evt
     */
    private void keyPressed(java.awt.event.KeyEvent evt) {
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);
        try {
            foo2(evt);
        } catch (IOException ex) {

        }
    }

    /**
     * Αν επιλεξει Ελληνικά τοτε τοτε στο isInitialized μπαινει true ωστε να
     * γινει ελεγχος παρακατω και σε περιπτωση που δεν ακολουθησει τις αρχικες
     * οδηγιες για να παιξει σωστα να του εμφανισει καταλληλο μηνυμα
     *
     * στο txt kai language μπαινουν καταλληλα Strings ωστε να αρχικοποιηθουν
     * μετα τα Ελληνικά και να φορτωθουν τα αντιστοιχα δεδομενα στα Ελληνικά.
     *
     * @param evt το γεγονος ActionEvent
     */
    private void GreekActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GreekActionPerformed
        txt = "dataGr.txt";
        language = "greek";
        isInitialized = true;
    }//GEN-LAST:event_GreekActionPerformed

    /**
     * Αν επιλεξει Αγγλικά τοτε στο isInitialized μπαινει true ωστε να γινει
     * ελεγχος παρακατω και σε περιπτωση που δεν ακολουθησει τις αρχικες οδηγιες
     * για να παιξει σωστα να του εμφανισει καταλληλο μηνυμα
     *
     * στο txt kai language μπαινουν καταλληλα Strings ωστε να αρχικοποιηθουν
     * μετα τα Αγγλικά και να φορτωθουν τα αντιστοιχα δεδομενα στα Αγγλικά.
     *
     * @param evt το γεγονος ActionEvent
     */
    private void EnglishActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EnglishActionPerformed
        txt = "dataEn.txt";
        language = "english";
        isInitialized = true;
    }//GEN-LAST:event_EnglishActionPerformed

    /**
     * Καλειται η giveBet(αναλυεται παρακατω) με πονταρισμα 250
     *
     * @param evt
     */
    private void bet1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bet1ActionPerformed
        giveBet(evt, 250);
    }//GEN-LAST:event_bet1ActionPerformed

    /**
     * Καλειται η giveBet(αναλυεται παρακατω) με πονταρισμα 5000
     *
     * @param evt
     */
    private void bet2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bet2ActionPerformed
        giveBet(evt, 500);
    }//GEN-LAST:event_bet2ActionPerformed

    /**
     * Καλειται η giveBet(αναλυεται παρακατω) με πονταρισμα 750
     *
     * @param evt
     */
    private void bet3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bet3ActionPerformed
        giveBet(evt, 750);
    }//GEN-LAST:event_bet3ActionPerformed

    /**
     * Καλειται η giveBet(αναλυεται παρακατω) με πονταρισμα 1000
     *
     * @param evt
     */
    private void bet4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bet4ActionPerformed
        giveBet(evt, 1000);
    }//GEN-LAST:event_bet4ActionPerformed

    /**
     * KeyPressed στo κουμπι λογω focus
     *
     * @param evt
     */
    private void bet1KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_bet1KeyPressed
        keyPressed(evt);
    }//GEN-LAST:event_bet1KeyPressed

    /**
     * KeyPressed στo κουμπι λογω focus
     *
     * @param evt
     */
    private void bet2KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_bet2KeyPressed
        keyPressed(evt);
    }//GEN-LAST:event_bet2KeyPressed

    /**
     * KeyPressed στo κουμπι λογω focus
     *
     * @param evt
     */
    private void bet3KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_bet3KeyPressed
        keyPressed(evt);
    }//GEN-LAST:event_bet3KeyPressed

    /**
     * KeyPressed στo κουμπι λογω focus
     *
     * @param evt
     */
    private void bet4KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_bet4KeyPressed
        keyPressed(evt);
    }//GEN-LAST:event_bet4KeyPressed

    /**
     * Παιρνουμε σαν συμβαση, οτι ασχετα με το ποιος θα απαντησει πρωτος στην
     * ερωτηση, το κουμπι που θα πατηθει πρωτο για το πονταρισμα αντιστοιχει
     * στον 1ο παικτη, ενω το 2ο στον 2ο παικτη. Σε ενα πεδιο bet το οποιο
     * ανανεωνεται καθε φορα εκχωρειται το επιθυμητο ποσο πονταρισματος του
     * πρωτου παικτη, ενω στο πεδιο betTwo αυτο του δευτερου παικτη. Με την
     * μεταβλητη hasBothBet ελεγχουμε αν ειναι η πρωτη φορα που πατιεται ενα
     * κουμπι απο τα bets αρα και οι ποντοι αντιστοιχουν στον 1ο παικτη, αλλιως
     * αν η μεταβλητη εχει αλλαξει (απο 0 σε 1) σημαινει οτι ο πρωτος εχει
     * πονταρει, αρα τωρα πονταρει ο δευτερος του οποιου οι ποντοι καταχωρουνται
     * στο αντιστοιχο πεδιο και τοτε μονο Μεσα στην giveBet γινεται το
     * setVisible στο παραθυρο για την ερωτηση και τις δοθεισες απαντησεις που
     * ακολουθουν αφου πριν πονταρουν και οι 2, θελουμε να φαινεται μονο η
     * κατηγορια της ερωτησης που παιζουν.
     *
     * @param evt το γεγονος που παταει για να διαλεξει του ποντους που θελει
     * @param pointsbet το νουμερο που αντιστοιχει στο πονταρισμα του
     */
    private void giveBet(java.awt.event.ActionEvent evt, int pointsbet) {
        if (hasBothBet == 0) {
            bet = pointsbet;
            hasBothBet = 1;

        } else {
            hasBothBet = 0;
            betTwo = pointsbet;
            question.setVisible(true);
            jPanel1.setVisible(true);
            question.setVisible(true);
            answers.setVisible(true);
        }
    }

    /**
     * Εχουμε θεσει ως συμβαση οτι: Ο παικτης 1 δινει τις απαντησεις του με τα
     * πληκτρα 1 2 3 4 που αντιστοιχουν στις αντιστοιχες εμφανισεις των
     * απαντησεων στα 1 2 3 4 και οτι Ο παικτης 2 δινει τις απαντησεις του με τα
     * πληκτρα U I O P που αντιστοιχουν στις αντιστοιχες εμφανισεις των
     * απαντησεων στα 1 2 3 4. Oταν καλειται η foo2 ελεγχεται αν ο παικτης που
     * απανταει τωρα ειναι ο πρωτος η ο δευτερος (με σειρα χρονου) με την
     * μεταβλητη theFirstWhoAnswered η οποια και μεταβαλλεται αναλογα. Την πρωτη
     * φορα που θα πατηθει κουμπι για την συγκεκριμενη ερωτηση, η μεταβλητη θα
     * ειναι false και αμεσως θα γινει true για να ξερουμε οτι εστω ενας παικτης
     * απαντησε.
     *
     * Στην συνεχεια με τις switch-case ελεγχεται το κουμπι που πατησε ο παικτης
     * και αν ανηκει στα κουμπια 1-2-3-4 θεωρουμε οτι η απαντηση αντιστοιχει
     * στον παικτη1 αλλιως αν τα κουμπια ειναι τα U-I-O-P σημαινει οτι
     * αναφερομαστε στον παικτη2. Αντιστοιχουμε τα κουμπια με τον αριθμο των
     * απαντησεων 1-2-3-4. Αναλογα με τον γυρο που παιζει καλουνται οι
     * αντιστοιχες συναρτησεις για να ελεγξουν την απαντηση του παικτη.
     *
     * Αν το theFirstWhoAnswered ειναι true τοτε σημαινει οτι ο παικτης που
     * απαντησε ειναι ο δευτερος κατα σειρα χρονου, αρα μετα την δικη του
     * απαντηση και τον ελεγχο της, το παιχνιδι θα συνεχισει σε επομενη ερωτηση.
     * Αυξανεται ο αριθμος των ερωτησεων που εχουν παιξει οι παικτες, και αν οι
     * ερωτησεις φτασαν τις 5 τοτε αλλαζουμε γυρο.
     *
     * Αυτο γινεται με την κληση της playGame, ειτε με το flag που επαιζε ήδη
     * ετσι ωστε να παιξει 5 ερωτησεις και να τελειωσει τον γυρο, είτε αν παιξει
     * 5 ερωτησεις διαλεγεται τυχαια ενα καινουργιο flag ωστε να παιχτει ενας
     * νεος γυρος.
     *
     * Μολις ολοκληρωσει τους 3 γυρους (που εχουμε ορισει εμεις οτι θα παιζει
     * για να φτανουν οι ερωτησεις που βαλαμε στο παιχνιδι) καλειται η συναρτηση
     * end().
     *
     * @param evt
     * @throws IOException
     */
    private void foo2(KeyEvent evt) throws IOException {
        setFocusable(true);
        setFocusTraversalKeysEnabled(false);
        if (theFirstWhoAnswered == false) {
            theFirstWhoAnswered = true;
            int hisAnswer = 0;
            switch (evt.getKeyCode()) {
                case KeyEvent.VK_1:
                    hisAnswer = 1;
                    break;
                case KeyEvent.VK_2:
                    hisAnswer = 2;
                    break;
                case KeyEvent.VK_3:
                    hisAnswer = 3;
                    break;
                case KeyEvent.VK_4:
                    hisAnswer = 4;
                    break;
                default:
                    break;
            }

            switch (evt.getKeyCode()) {
                case KeyEvent.VK_U:
                    hisAnswer = 1;
                    break;
                case KeyEvent.VK_I:
                    hisAnswer = 2;
                    break;
                case KeyEvent.VK_O:
                    hisAnswer = 3;
                    break;
                case KeyEvent.VK_P:
                    hisAnswer = 4;
                    break;
                default:
                    break;
            }

            if (evt.getKeyCode() == KeyEvent.VK_1 || evt.getKeyCode() == KeyEvent.VK_2 || evt.getKeyCode() == KeyEvent.VK_3 || evt.getKeyCode() == KeyEvent.VK_4) {
                checkRound(player1, hisAnswer, flagForRound);
            } else if (evt.getKeyCode() == KeyEvent.VK_U || evt.getKeyCode() == KeyEvent.VK_I || evt.getKeyCode() == KeyEvent.VK_O || evt.getKeyCode() == KeyEvent.VK_P) {
                checkRound(player2, hisAnswer, flagForRound);
            }

        } else {
            numberOfPlayedQuestions = numberOfPlayedQuestions + 1;
            int herAnswer = 0;
            theFirstWhoAnswered = false; //gia na bei meta panw
            switch (evt.getKeyCode()) {
                case KeyEvent.VK_U:
                    herAnswer = 1;
                    break;
                case KeyEvent.VK_I:
                    herAnswer = 2;
                    break;
                case KeyEvent.VK_O:
                    herAnswer = 3;
                    break;
                case KeyEvent.VK_P:
                    herAnswer = 4;
                    break;
                default:
                    break;
            }

            switch (evt.getKeyCode()) {
                case KeyEvent.VK_1:
                    herAnswer = 1;
                    break;
                case KeyEvent.VK_2:
                    herAnswer = 2;
                    break;
                case KeyEvent.VK_3:
                    herAnswer = 3;
                    break;
                case KeyEvent.VK_4:
                    herAnswer = 4;
                    break;
                default:
                    break;
            }

            if (evt.getKeyCode() == KeyEvent.VK_1 || evt.getKeyCode() == KeyEvent.VK_2 || evt.getKeyCode() == KeyEvent.VK_3 || evt.getKeyCode() == KeyEvent.VK_4) {
                checkRound(player1, herAnswer, flagForRound);
            } else if (evt.getKeyCode() == KeyEvent.VK_U || evt.getKeyCode() == KeyEvent.VK_I || evt.getKeyCode() == KeyEvent.VK_O || evt.getKeyCode() == KeyEvent.VK_P) {
                checkRound(player2, herAnswer, flagForRound);
            }

            question.setVisible(false);
            answers.setVisible(false);
            if (numberOfPlayedQuestions == 5) {
                numberOfRounds += 1;
            }
            player1Info.setText(bundle.getString("paiktis1") + ster.getPoints() + bundle.getString("pontous"));
            player2Info.setText(bundle.getString("paiktis2") + eleni.getPoints() + bundle.getString("pontous"));
            if (numberOfRounds < NUMBER_OF_ROUNDS) {
                firstRightAnswer = true;
                if (numberOfPlayedQuestions == 5) {
                    numberOfPlayedQuestions = 0;
                    flagForRound = getRandom();
                    q = gamePlay.getAQuestionFromARound(flagForRound);
                    playGame(flagForRound);
                    System.out.println("neos guros");
                } else {
                    q = gamePlay.getAQuestionFromARound(flagForRound);
                    playGame(flagForRound);
                }
            } else {
                end();
            }
        }
    }

    /**
     * Συναρτηση που ελεγχει ποια συναρτηση θα κληθει για να ελεγξει την
     * απαντηση του παικτη αναλογα τον γυρο που παιζει εκεινη τη στιγμη. Με την
     * switch-case ελεγχεται το ποια συναρτηση θα καλεστει.
     *
     * @param player ο παικτης του οποιου η απαντηση θα ελεγχθει.
     * @param answer η απαντηση του παικτη
     * @param round ο γυρος που παιζεται
     */
    private void checkRound(int player, int answer, int round) {
        switch (round) {
            case 0:
                checkChoiceForRoundRightAnswer(player, answer);
                break;
            case 1:
                checkChoiceForRoundBet(player, answer);
                break;
            case 2:
                checkChoiceForRoundStopwatch(player, answer);
                timer.restart();
                break;
            case 3:
                checkChoiceForRoundQuickAnswer(player, answer);
                break;
            case 4:
                checkChoiceForRoundThermometer(player, answer);
                break;
            default:
                break;
        }
    }

    /**
     * Μεθοδος για αναπαραγωγη ενος τυχαιου αριθμου απο 0-4 για να παιξουν εναν
     * τυχαιο γυρο απο τους 5 που υπαρχουν στο παιχνιδι για 2.
     *
     * @return τον τυχαιο αριθμο
     */
    public int getRandom() {
        Random r1 = new Random();
        int i1 = r1.nextInt(5);
        return i1;
    }

    /**
     * Αυτη η μεθοδος σχετιζεται με το κομματι της διεπαφης του χρηστη αφου
     * εμφανιζει ερωτησεις και απαντησεις, τα ονοματα των γυρων και το ρολοι σε
     * περιπτωση που παιζει γυρο Σταματησε το χρονομετρο. Το 0 αντιστοιχει στον
     * γυρο Σωστη απαντηση το 1 στον Γυρο Πονταρισμα και το 2 στον Γυρο
     * Σταματησε το Χρονομετρο το 3 στον Γυρο Γρηγορη Απαντηση και το 4 στον
     * Γυρο Θερμομετρο
     *
     * @param round το νουμερο που υποδηλωνει ποιον γυρο παιζει καθε φορα
     * @return
     * @throws java.io.IOException
     */
    public int playGame(int round) throws IOException {

        disableBets();
        image.setIcon(null);
        image.setVisible(false);
        switch (round) {
            //Σωστη απαντηση
            case 0:
                clock.setVisible(false);
                category.setVisible(false);
                question.setVisible(true);
                betInfo.setVisible(false);
                answers.setVisible(true);
                image.setVisible(false);
                progress.setText(bundle.getString("giros1"));
                question.setText(q.getQuestionName());
                checkToShowImage(q);
                showTheAnswers(q);
                rightAnswer = q.keepTheRightAnswer();
                //EDW TWRA PREPEI NA PATHSEI TA KOUMPIA
                break;

            //Πονταρισμα
            case 1:
                UnselectButtons();
                progress.setText(bundle.getString("giros2"));
                clock.setVisible(false);
                answers.setVisible(false);
                question.setVisible(false);
                betInfo.setVisible(true);
                image.setVisible(false);
                jPanel1.setVisible(true);
                category.setText(q.getCategory());
                category.setVisible(true);
                betInfo.setText(bundle.getString("posous_pontous_pontareis"));
                showBets();
                question.setText(q.getQuestionName());
                rightAnswer = q.keepTheRightAnswer();
                checkToShowImage(q);
                showTheAnswers(q);
                //EDW PATAEI APANTHSH
                break;

            //Σταματησε το Χρονομετρο
            case 2:
                clock.setVisible(true);
                category.setVisible(false);
                question.setVisible(true);
                betInfo.setVisible(false);
                image.setVisible(false);
                answers.setVisible(true);
                progress.setText(bundle.getString("giros3"));
                question.setText(q.getQuestionName());
                checkToShowImage(q);
                showTheAnswers(q);
                //MOLIS EMFANISTEI H ERWTHSH & OI APANTHSEIS THS, TOTE ARXIZEI NA METRAEI O XRONOS
                startClock();
                rightAnswer = q.keepTheRightAnswer();
                time = System.currentTimeMillis();
                //EDW PATAEI APANTHSH
                break;

            //Γρηγορη Απαντηση
            case 3:
                clock.setVisible(false);
                category.setVisible(false);
                question.setVisible(true);
                betInfo.setVisible(false);
                answers.setVisible(true);
                progress.setText(bundle.getString("giros4"));
                question.setText(q.getQuestionName());
                checkToShowImage(q);
                showTheAnswers(q);
                rightAnswer = q.keepTheRightAnswer();
                //EDW PATAEI APANTHSH
                break;

            //Θερμόμετρο
            case 4:
                clock.setVisible(false);
                category.setVisible(false);
                question.setVisible(true);
                betInfo.setVisible(false);
                answers.setVisible(true);
                progress.setText(bundle.getString("giros5"));
                question.setText(q.getQuestionName());
                checkToShowImage(q);
                showTheAnswers(q);
                rightAnswer = q.keepTheRightAnswer();
                //EDW PATAEI APANTHSH
                break;
            default:
                break;
        }
        return 1;
    }

    /**
     * Η μεθοδος αυτη ασχολειται αποκλειστικα με την εμφανιση και την αντιστροφη
     * μετρηση του ρολογιου
     */
    public void startClock() {
        clock.setText("5 sec");
        timer = new Timer(1000, new ActionListener() {
            private int count = 5;

            @Override
            public void actionPerformed(ActionEvent e) {
                if (count <= 0) {
                    ((Timer) e.getSource()).stop();
                } else {
                    clock.setText(Integer.toString(count) + " sec");
                    count -= 1;
                }
                clock.setText(Integer.toString(count) + " sec");
            }

        });
        timer.start();
    }

    /**
     * Η συναρτηση αυτη καλειται οταν το παιχνιδι τελειωσει και απλα κανει τα
     * καταλληλα setVisible(false) στο παραθυρο ωστε να μην εμφανιζεται τιποτα
     * αλλο εκτος των τελικων ποντων των δυο παικτων! Ακομα, δημιουργειται ενα
     * αντικειμενο της ScoreWriter με παραμετρους τους ποντους των 2 παικτων και
     * καλειται η μεθοδος writeScoreFor2 ωστε να γραψει στο αρχειο κειμενου το
     * τελικο σκορ και τον νικητη του παιχνιδιου.
     *
     * @throws IOException
     */
    public void end() throws IOException {
        System.out.println("telos!!");

        progress.setVisible(false);
        answers.setVisible(false);
        question.setVisible(false);
        image.setVisible(false);
        betInfo.setVisible(false);
        category.setVisible(false);
        clock.setVisible(false);
        jPanel1.setVisible(false);
        player1Info.setVisible(false);
        player2Info.setVisible(false);

        int pointsForSter = ster.getPoints();
        question.setText(bundle.getString("end") + pointsForSter + bundle.getString("pontous"));

        int pointsForEleni = eleni.getPoints();
        answer.setText(bundle.getString("end") + pointsForEleni + bundle.getString("pontous"));
        question.setVisible(true);

        scoreWriter = new ScoreWriter(ster.getPoints(), eleni.getPoints());
        scoreWriter.writeScoreFor2();

    }

    /**
     * Η συναρτηση αυτη εχει ως ορισματα τον παικτη για του οποιου η απαντηση θα
     * ελεγχει και η απαντηση που εδωσε. Ελεγχεται αν η απαντηση του ειναι η
     * ιδια με την σωστη απαντηση.
     *
     * Αν ναι κερδιζει 1000 ποντους , αλλιως του εμφανιζει λαθος. Αναλογα με τον
     * παικτη οι ποντοι αυτοι μπαινουν ή στον παικτη 1 ή στον παικτη 2 καλωντας
     * την συναρτηση win για εναν απο τους δυο.
     *
     * @param player ο παικτης του οποιου η απαντηση θα ελεγχθει
     * @param hisAnswer το νουμερο που εχει δωσει το οποιο αντιστοιχει στην
     * απαντηση του
     */
    public void checkChoiceForRoundRightAnswer(int player, int hisAnswer) {
        if (hisAnswer == rightAnswer) {
            String result;
            result = bundle.getString("swsto") + bundle.getString("kerdises") + 1000 + "  " + bundle.getString("pontous");
            answer.setText(result);
            if (player == 1) {
                ster.win(1000);
            } else if (player == 2) {
                eleni.win(1000);
            }
        } else {
            answer.setText(bundle.getString("lathos"));
        }
    }

    /**
     * Αν απαντησει σωστα κερδιζει τους ποντους που πονταρε αλλιως τους χανει.
     * Για να ξερουμε ποσους ποντους θα κερδισει η θα χασει ο καθενας, αναλογα
     * με τον παικτη για τον οποιο ελεγχεται η απαντηση, αν αυτος ειναι ο
     * παικτης1 αναφερομαστε στο πεδιο της κλασης bet αλλιως αν ειναι ο παικτης2
     * στο πεδιο της κλασης betTwo. Aν εχει απαντησει σωστα καλειται η συναρτηση
     * win για τον εκαστοτε παικτη, αλλιως καλειται η συναρτηση Lose και
     * εμφανιζονται τα αντιστοιχα μηνυματα.
     *
     * @param player ο παικτης του οποιου η απαντηση θα ελεγχθει
     * @param hisAnswer το νουμερο που εχει δωσει το οποιο αντιστοιχει στην
     * απαντηση του
     *
     */
    public void checkChoiceForRoundBet(int player, int hisAnswer) {
        String result;
        if (hisAnswer == rightAnswer) {
            if (player == 1) {
                result = bundle.getString("swsto") + bundle.getString("kerdises") + bet + "  " + bundle.getString("pontous");
                answer.setText(result);
                ster.win(bet);
            } else if (player == 2) {
                result = bundle.getString("swsto") + bundle.getString("kerdises") + betTwo + "  " + bundle.getString("pontous");
                answer.setText(result);
                eleni.win(betTwo);
            }
        } else {
            if (player == 1) {
                result = bundle.getString("lathos") + bundle.getString("exases") + bet + "  " + bundle.getString("pontous");
                answer.setText(result);
                ster.lose(bet);
            } else if (player == 2) {
                result = bundle.getString("lathos") + bundle.getString("exases") + betTwo + "  " + bundle.getString("pontous");
                answer.setText(result);
                eleni.lose(betTwo);
            }
        }
    }

    /**
     * Ο χρονος που ειχε αρχισει να μετραει οταν μπηκε στον γυρο Σταματησε το
     * Χρονομετρο σταματαει οταν δωσει απαντηση Αν η απαντηση του ειναι σωστη το
     * υπολοιπο τον millis πολλ/ζεται με το 0.2 και αυτοι ειναι οι ποντοι του.
     * Αν ο χρονος ειναι > απο 5 sec τοτε παρολο που εχει απαντησει σωστα
     * παιρνει 0 Το χρονομετρο βεβαια εξακολουθει να λειτουργει μεχρι να εχουν
     * δωσει απαντηση και οι 2 παικτες. Αναλογως με τον παικτη player του οποιου
     * ελεγχεται η απαντηση, καλειται η συναρτηση win για τους ποντους (όσους
     * και αν ) καταφερε να κερδισει. Αλλιως εμφανιζεται οτι απαντησε λαθος.
     *
     * @param player ο παικτης του οποιου η απαντηση θα ελεγχθει
     * @param hisAnswer το νουμερο που εχει δωσει το οποιο αντιστοιχει στην
     * απαντηση του
     */
    public void checkChoiceForRoundStopwatch(int player, int hisAnswer) {
        int pointsForRoundStopwatch;
        long endTime = System.currentTimeMillis();
        long millisLeft;

        if (hisAnswer == rightAnswer) {
            if ((endTime - time) / 1000 < 5) {
                //MESA STA 5 SECOND
                millisLeft = 5000 - (endTime - time);
                pointsForRoundStopwatch = (int) (millisLeft * 0.2);
            } else {
                pointsForRoundStopwatch = 0;
            }
            answer.setText(bundle.getString("swsto") + bundle.getString("kerdises") + pointsForRoundStopwatch + " " + bundle.getString("pontous"));
            if (player == 1) {
                ster.win(pointsForRoundStopwatch);
            } else if (player == 2) {
                eleni.win(pointsForRoundStopwatch);
            }
        } else {
            answer.setText(bundle.getString("lathos"));
        }
    }

    /**
     * Aν ο παικτης εχει απαντησει σωστα και η μεταβλητη theFirstWhoAnswered
     * ειναι true, δλδ ειναι ο πρωτος απο τους 2 παικτες που απαντησε στην
     * ερωτηση,δλδ ο πιο γρηγορος, τοτε καλειται η συναρτηση win για τον
     * συγκεκριμενο παικτη, και κερδιζει 1000 ποντους.
     *
     * Aν ο παικτης εχει απαντησει σωστα και η μεταβλητη theFirstWhoAnswered
     * ειναι false, δλδ δεν ειναι ο πρωτος απο τους 2 παικτες που απαντησε στην
     * ερωτηση,δλδ δεν ειναι ο πιο γρηγορος, τοτε ελεγχεται και μια δευτερη
     * συνθηκη. Η συνθηκη αυτη σχετιζεται με την μεταβλητη firstRightAnswer.
     *
     * Αν ειναι true, δλδ ειναι μεν ο δευτερος σε χρονο παικτης που απαντησε,
     * αλλα ο πρωτος δεν ειχε απαντησει σωστα, τοτε καλειται η συναρτηση win για
     * τον συγκεκριμενο παικτη και κερδιζει παλι 1000 ποντους.
     *
     * Αν ειναι false, δλδ ειναι ο δευτερος σε χρονο παικτης που απαντησε, και
     * συγχρονως ο πρωτος ειχε απαντησει σωστα, τοτε καλειται η συναρτηση win
     * για τον συγκεκριμενο παικτη και κερδιζει 500 ποντους.
     *
     * Αν ο παικτης εχει απαντησει σωστα, τοτε η μεταβλητη firstRightAnswer
     * γινεται false.
     *
     * Αν ο παικτης εχει απαντησει λαθος δεν κερδιζει τιποτα και του εμφανιζεται
     * το καταλληλο μηνυμα.
     *
     * @param player ο παικτης του οποιου η απαντηση θα ελεγχθει
     * @param hisAnswer το νουμερο που εχει δωσει το οποιο αντιστοιχει στην
     * απαντηση του
     *
     */
    private void checkChoiceForRoundQuickAnswer(int player, int hisAnswer) {
        if (hisAnswer == rightAnswer) {
            String result;
            if (theFirstWhoAnswered == true) {
                result = bundle.getString("swsto") + bundle.getString("kerdises") + 1000 + "  " + bundle.getString("pontous");
                answer.setText(result);
                if (player == 1) {
                    ster.win(1000);
                } else if (player == 2) {
                    eleni.win(1000);
                }
            } else if ((theFirstWhoAnswered == false) && (firstRightAnswer == true)) {
                result = bundle.getString("swsto") + bundle.getString("kerdises") + 1000 + "  " + bundle.getString("pontous");
                answer.setText(result);
                if (player == 1) {
                    ster.win(1000);
                } else if (player == 2) {
                    eleni.win(1000);
                }
            } else if ((theFirstWhoAnswered == false) && (firstRightAnswer == false)) {
                result = bundle.getString("swsto") + bundle.getString("kerdises") + 500 + "  " + bundle.getString("pontous");
                answer.setText(result);
                if (player == 1) {
                    ster.win(500);
                } else if (player == 2) {
                    eleni.win(500);
                }
            }
            firstRightAnswer = false;

        } else {
            answer.setText(bundle.getString("lathos"));
        }
    }

    /**
     * Η συναρτηση αυτη εχει ως ορισματα τον παικτη για του οποιου η απαντηση θα
     * ελεγχει και η απαντηση που εδωσε. Υπαρχουν ως πεδια στο GUI2 δυο counter
     * (counter1 και counter2) τα οποια αυξανονται κατα ενα οταν ο παικτης στον
     * οποιο αντιστοιχει ενας απο τους μετρητες, εχει απαντησει σωστα. Οι
     * counter ηταν αρχικοποιημενοι στο 0 οποτε αν και μονο αν ο counter του
     * παικτη για τον οποιο ελεγχθει η απαντηση ειναι ισος με 4 και αν η
     * απαντηση του ειναι η ιδια με την σωστη απαντηση, τοτε μονο ο παικτης
     * κερδιζει 5000 ποντους αλλιως του εμφανιζει λαθος. Αναλογα με τον παικτη
     * οι ποντοι αυτοι μπαινουν ή στον παικτη 1 ή στον παικτη 2 καλωντας την
     * συναρτηση win για εναν απο τους δυο.
     *
     * @param player ο παικτης του οποιου η απαντηση θα ελεγχθει
     * @param hisAnswer το νουμερο που εχει δωσει το οποιο αντιστοιχει στην
     * απαντηση του
     */
    private void checkChoiceForRoundThermometer(int player, int hisAnswer) {
        if (hisAnswer == rightAnswer) {
            String result;
            if (player == 1) {
                if (counter1 == 4) {
                    result = bundle.getString("swsto") + bundle.getString("kerdises") + 5000 + "  " + bundle.getString("pontous");
                    answer.setText(result);
                    ster.win(5000);
                    counter1 = 0;
                } else {
                    counter1 = counter1 + 1;
                    result = bundle.getString("swsto");
                    answer.setText(result);
                }

            } else if (player == 2) {
                if (counter2 == 4) {
                    result = bundle.getString("swsto") + bundle.getString("kerdises") + 5000 + "  " + bundle.getString("pontous");
                    answer.setText(result);
                    eleni.win(5000);
                    counter2 = 0;
                } else {
                    counter2 = counter2 + 1;
                    result = bundle.getString("swsto");
                    answer.setText(result);
                }

            }

        } else {
            answer.setText(bundle.getString("lathos"));
        }

    }

    /**
     * "καθαριζει" την προηγουμενη επιλογη πονταρισματος του χρηστη για την νεα
     * ερωτηση
     *
     */
    public void UnselectButtons() {
        bet1.setSelected(false);
        bet2.setSelected(false);
        bet3.setSelected(false);
        bet4.setSelected(false);
    }

    /**
     * Καθιστα αορατα τα πονταρισματα για λογους διαμορφωσης κατα την διεξαγωγη
     * του παιχνιδιου
     */
    public void disableBets() {
        bet1.setVisible(false);
        bet2.setVisible(false);
        bet3.setVisible(false);
        bet4.setVisible(false);
        betInfo.setVisible(false);
    }

    /**
     * Καθιστα ορατα τα πονταρισματα για λογους διαμορφωσης κατα την διεξαγωγη
     * του παιχνιδιου
     *
     */
    public void enableBets() {
        bet1.setVisible(true);
        bet2.setVisible(true);
        bet3.setVisible(true);
        bet4.setVisible(true);
        jPanel1.setVisible(true);
    }

    /**
     * Εμφανιζει στον χρηστη και κανει set στα labels τα επιτρεπτα ποσα
     * πονταρισματος.
     */
    public void showBets() {
        betInfo.setText(bundle.getString("posous_pontous_pontareis"));
        bet1.setText("250");
        bet2.setText("500");
        bet3.setText("750");
        bet4.setText("1000");
        enableBets();
    }

    /**
     * Μεθοδος ωστε να εμφανισει τις απαντησεις καθε ερωτησης.
     *
     * @param q η ερωτηση για να εμφανιστουν οι απαντησεις της στα αντιστοιχα
     * labels
     */
    public void showTheAnswers(Question q) {
        answer1.setText("1. " + q.getAnswers().get(0));
        answer2.setText("2. " + q.getAnswers().get(1));
        answer3.setText("3. " + q.getAnswers().get(2));
        answer4.setText("4. " + q.getAnswers().get(3));
    }

    /**
     * Η μεθοδος αυτη ελεγχει αν η ερωτηση ειναι instanceof της
     * QuestionWithImage ωστε να εμφανισει την αντιστοιχη εικονα και την κανει
     * set σε ενα label.
     *
     * @param q η ερωτηση για την οποια θα γινει ελεγχος για την εικονα
     */
    public void checkToShowImage(Question q) {
        if (q instanceof QuestionWithImage) {
            String filename = q.getImage();
            filename = "/images/" + filename + ".jpg";
            URL imageURL = getClass().getResource(filename);
            if (imageURL != null) {
                icon = new ImageIcon(imageURL);
            }
            image.setIcon(icon);
            image.setVisible(true);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Gui2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Gui2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Gui2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Gui2.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Gui2().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem English;
    private javax.swing.JMenuItem Greek;
    private javax.swing.JMenu Language;
    private javax.swing.JLabel answer;
    private javax.swing.JLabel answer1;
    private javax.swing.JLabel answer2;
    private javax.swing.JLabel answer3;
    private javax.swing.JLabel answer4;
    private javax.swing.JPanel answers;
    private javax.swing.JRadioButton bet1;
    private javax.swing.JRadioButton bet2;
    private javax.swing.JRadioButton bet3;
    private javax.swing.JRadioButton bet4;
    private javax.swing.JLabel betInfo;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JLabel category;
    private javax.swing.JLabel clock;
    private javax.swing.JMenuItem exit;
    private javax.swing.JMenu file;
    private javax.swing.JLabel image;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton play;
    private javax.swing.JLabel player1Info;
    private javax.swing.JLabel player2Info;
    private javax.swing.JLabel progress;
    private javax.swing.JLabel question;
    // End of variables declaration//GEN-END:variables

}
